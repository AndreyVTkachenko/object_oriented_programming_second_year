Продемонстрировать применение принципов, усвоенных на семинаре. Нужно в проекте прокомментировать участки кода, которые
рефакторим, какой принцип применяем и почему.

1. calculator
Класс ViewCalculator нарушает принцип единственной ответственности, так как выполняет как ввод данных, так и логику
управления калькулятором. Это затрудняет тестирование и поддержку кода. Разделим ответственность на отдельные классы:
один класс для управления логикой калькулятора и другой для обработки пользовательского интерфейса.

Класс Calculator не расширяем, так как любая модификация логики требует изменения самого класса. Можно использовать
декоратор, чтобы расширить функциональность без изменения существующего класса.

ViewCalculator жестко связан с реализацией ввода через консоль, что затрудняет тестирование и изменение интерфейса ввода.
Используем интерфейс для работы с вводом/выводом, чтобы можно было легко заменить реализацию.


2. jobagency
Класс Company отвечает и за генерацию случайной зарплаты, и за отправку предложения агентству. Это нарушает принцип
единственной ответственности. Нужно разделить функционал генерации зарплаты и отправки предложения. Company должен
только отправлять предложения, а генерацию можно вынести в отдельный класс или метод.

Классы Student и Master не позволяют легко добавить новую логику для обработки предложений, если, например, потребуется
добавить новый тип наблюдателя с другой логикой. Нужно использовать абстракции или стратегии для обработки предложений,
чтобы упростить расширение функционала.

Класс Company жестко связан с интерфейсом Publisher. Это делает тестирование сложнее, так как сложно подменить
зависимость для проверки. Можно использовать инъекцию зависимостей через конструктор.


3. meteo
Класс Main выполняет слишком много задач, включая взаимодействие с разными типами датчиков и обработку их данных.
Класс MeteoStore жестко привязан к интерфейсу MeteoSensor. Добавление новых типов датчиков требует изменения
существующего кода.
Не соблюдается полное соответствие интерфейсу, так как у новых датчиков структура данных отличается.
Интерфейс MeteoSensor содержит методы, которые не нужны всем датчикам.
Классы зависят от конкретных реализаций, а не от абстракций, что затрудняет расширяемость системы.


